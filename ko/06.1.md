## 6.1 Session and cookies
## 6.1 세션과 쿠키

Sessions and cookies are two very common web concepts, and are also very easy to misunderstand. However, they are extremely important for the authorization of pages, as well as for gathering page statistics. Let's take a look at these two use cases.   
세션과 쿠키는 두개의 아주 일반적인 웹 개념이며 쉽게 이해하지 못하는 부분이기도 합니다. 어찌됬건 그것들은 페이지의 인증을 위해 극히 중요하며, 게다가 정적인 페이지모임을 위한 것이기도 합니다. 아래 두가지 사용 예제를 살펴보세요. 

Suppose you want to crawl a page that restricts public access, like a twitter user's homepage for instance. Of course you can open your browser and type in your username and password to login and access that information, but so-called "web crawling" means that we use a program to automate this process without any human intervention. Therefore, we have to find out what is really going on behind the scenes when we use a browser to login.  
당신이 트위터 유저의 홈페이지처럼 공개적인 접근을 통한 페이지 크로울링을 제한하고 싶다면 당신은 당연하게도 브라우저를 열고 로그인을 하기위해 당신의 id와 password를 타이핑한 뒤에 그 정보에 접근 할 수 있을 것입니다. 하지만 이것은 "web crawling"이 아닙니다. "web crwling"은 사람이 개입하지 않고 자동으로 이 프로세스를 진행하는 프로그램을 사용하는 것 입니다. 그러므로 우리는 브라우저로 로그인을 할때 그 뒤에서 일어나는 일들이 어떻게 되어가는지 찾아봐야 합니다.  

When we first receive a login page and type in a username and password, after we press the "login" button, the browser sends a POST request to the remote server. The Browser redirects to the user homepage after the server verifies the login information and returns an HTTP response. The question here is, how does the server know that we have access priviledges for the desired webpage? Because HTTP is stateless, the server has no way of knowing whether or not we passed the verification in last step. The easiest and perhaps the most naive solution is to append the username and password to the URL. This works, but puts too much pressure on the server (the server must validate every request against the database), and can be detrimental to the user experience. An alternative way of achieving this goal is to save the user's identity either on the server side or client side using cookies and sessions.  
우리가 첫번째 응답으로 로그인 페비지를 보고,  로그인 페이지에서 유저네임과 패스워드를 입력하고 "login"버튼을 누른뒤에 브라우저는 원격 서버로 POST요청을 보냅니다. 서버가 로그인 정보를 검증하고 HTTP응답을 보낸후 브라우저는 유저 홈페이지로 리다이렉트 합니다. 의문점은 바로 여기 있습니다. 서버는 어떻게 웹 페이지에서 클라이언트의 접속 권한을 알 수 있을까요? HTTP는 상태가 없는데 말이죠. 서버는 우리가 마지막 단계에서 검증을 통과하는지 여부를 알 방법이 없습니다. 가장 쉽고 지나치게 단순한 해결책은 URL에 유저네임과 패스워드를 추가하는 것입니다. 이것은 동작하지만 서버로 많은 요청을 보내게 됩니다.(서버는 모든 요청에 대하여 데이터베이스와 대조하여 검증 해야만 합니다.) 그리고 이것은 유저 경험에 유해합니다. 이것을 대체할 방법은 유저의 식별자를 서버사이드와 클라이언트 사이드에 쿠키와 세션으로 저장하는 것 입니다.   

Cookies, in short, store historical information (including user login information) on the client's computer. The client's browser sends these cookies everytime the user visits the same website, automatically completing the login step for the user.  
쿠키는 클라이언트 컴퓨터에 활동기록 정보를(유저 로그인 정보를 포함하여) 짧게 저장합니다. 브라우저는 유저가 같은 웹사이트를 방문 할 때마다 이 쿠키를 전송하고 유저를 위해 로그인을 위한 절차를 자동으로 완료합니다. 


![](images/6.1.cookie2.png?raw=true)

Figure 6.1 cookie principle.  
그림 6.1 쿠키 원칙.

Sessions, on the other hand, store historical information on the server side. The server uses a session id to identify different sessions, and the session id that is generated by the server should always be random and unique. You can use cookies or URL arguments to get the client's identity.  
한편으로 세션은 활동기록은 서버사이드에 저장합니다. 서버는 세션아이디로 독립적인 다른 세션의 아이디로 사용하며 세션아이디는 서버에서 항상 무작위성과 유일함이 보장되도록 생성됩니다. 당신은 쿠키 또는 URL 인자를 이용하여 클라이언트의 신분을 얻을 수 있습니다.

![](images/6.1.session.png?raw=true)

Figure 6.2 session principle.  
그림 6.2 세션 원칙.

## Cookies
## 쿠키

Cookies are maintained by browsers. They can be modified during communication between webservers and browsers. Web applications can access cookie information when users visit the corresponding websites. Within most browser settings, there is one setting pertaining to cookie privacy. You should be able to see something similar to the following when you open it.  
쿠키는 브라우저가 유지하며 웹서버와 브라우저간의 통신하는동안 정의 할 수 있습니다. 웹 어플리케이션은 유저가 웹사이트에 방문했을때 쿠키정보에 접근할 수 있습니다. 대부분의 브라우저 설정에서 쿠키의 개인정보 설정이 존재합니다. 쿠키정보를 열 경우 아래와 비슷한 화면을 볼 수 있을겁니다. 

![](images/6.1.cookie.png?raw=true)

Figure 6.3 cookie in browsers.
그림 6.3 브라우저 안의 쿠키.

Cookies have an expiry time, and there are two types of cookies distinguished by their life cyles: session cookies and persistent cookies.  
쿠키는 만료시간이 있으며 쿠키의 유명한 라이프 사이클의 두가지 타입은 세션 쿠키와 퍼시스턴트 쿠키가 있습니다.  

If your application doesn't set a cookie expiry time, the browser will not save it into the local file system after the browser is closed. These cookies are called session cookies, and this type of cookie is usually saved in memory instead of to the local file system.  
만약 당신의 어플리케이션이 쿠키 만료시간을 설정하지 않는다면 브라우저는 로컬 파일 시스템에 쿠키를 저장하지 않을 것입니다. 이 쿠키를 세션 쿠키라고 부르며 이 타입은 대게 로컬 파일 시스템 메모리에 저장합니다.  

If your application does set an expiry time (for example, setMaxAge(60*60*24)), the browser *will* save this cookie to the local file system, and it will not be deleted until reaching the allotted expiry time. Cookies that are saved to the local file system can be shared by different browser processes -for example, by two IE windows; different browsers use different processes for dealing with cookies that are saved in memory. 　　
만약 당신의 어플리케이션이 쿠키 만료시간을 설정한다면(예를 들자면, setMaxAge(60*60*24)), 브라우저는 이 쿠키를 로컬 파일 시스템에 저장 *할* 것이며 만료 시간이 되기 전에는 이 쿠키를 삭제하지 않을 것입니다. 쿠키는 로컬 파일시스템에 저장되어 다른 브라우저 프로세스와 공유가 가능합니다. -예를 들자면, 윈도우에서 두개의 익스플로러를 띄우는 경우; 서로 다른 브라우저는 쿠키를 메모리에 저장하기 위한 방식으로 다른 프로세스를 사용합니다. 

## Set cookies in Go
## 'Go'에서 쿠키 저장

Go uses the `SetCookie` function in the `net/http` package to set cookies:  
'Go'는 `net/http`패키지 안에 있는 `SetCookie`함수를 사용하여 쿠키를 저장합니다:

	http.SetCookie(w ResponseWriter, cookie *Cookie)

`w` is the response of the request and cookie is a struct. Let's see what it looks like:  
`w`는 요청의 응답이며 쿠키는 struct입니다. 어떻게 보이는지 살펴보세요:

	type Cookie struct {
	    Name       string
	    Value      string
	    Path       string
	    Domain     string
	    Expires    time.Time
	    RawExpires string
	
	// MaxAge=0 means no 'Max-Age' attribute specified.
	// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
	// MaxAge>0 means Max-Age attribute present and given in seconds
	    MaxAge   int
	    Secure   bool
	    HttpOnly bool
	    Raw      string
	    Unparsed []string // Raw text of unparsed attribute-value pairs
	}

Here is an example of setting a cookie:  
여기 쿠키 세팅의 예제가 있습니다:

	expiration := time.Now().Add(365 * 24 * time.Hour)
	cookie := http.Cookie{Name: "username", Value: "astaxie", Expires: expiration}
	http.SetCookie(w, &cookie)
　　

## Fetch cookies in Go  
## 'Go'에서의 쿠키 Fetch

The above example shows how to set a cookie. Now let's see how to get a cookie that has been set:  
위의 예제는 어떻게 쿠키를 세팅하는지 보여줍니다. 이제 세팅된 쿠키를 어떻게 가져오는지 살펴보세요:

	cookie, _ := r.Cookie("username")
	fmt.Fprint(w, cookie)

Here is another way to get a cookie:  
이것은 쿠키를 가져오는 다른 방법입니다:

	for _, cookie := range r.Cookies() {
	    fmt.Fprint(w, cookie.Name)
	}

As you can see, it's very convenient to get cookies from requests.  
당신도 볼 수 있듯이, 리퀘스트에서 쿠키를 가져오는것은 매우 간편합니다.

## Sessions  
## 세션

A session is a series of actions or messages. For example, you can think of the actions you between picking up your telephone to hanging up to be a type of session. When it comes to network protocols, sessions have more to do with connections between browsers and servers.  
세션은 액션 또는 메시지의 연속입니다. 예를 들자면, 당신이 전화를 받고 끊는것 사이에서의 액션을 세션의 타입이라고 생각해 볼 수 있습니다. 이것이 네트워크 프로토콜로 올때 세션은 브라우저와 서버 사이의 더 많은 연결을 해야합니다. 

Sessions help to store the connection status between server and client, and this can sometimes be in the form of a data storage struct.  
세션은 서버와 클라이언트 사이의 연결 상태를 저장하도록 도와주며 때때로 데이터 폼을 구조체로 저장할 수 있습니다.

Sessions are a server side mechanism, and usually employ hash tables (or something similar) to save incoming information.  
세션은 서버사이드 메커니즘이며 정보들을 저장하기위해 보통 해시 테이블(또는 비슷한)을 사용합니다.

When an application needs to assign a new session to a client, the server should check if there are any existing sessions for same client with a unique session id. If the session id already exists, the server will just return the same session to the client. On the other hand, if a session id doesn't exist for the client, the server creates a brand new session (this usually happens when the server has deleted the corresponding session id, but the user has appended the old session manually).  
어플리케이션이 클라이언트에 새로운 세션을 할당할때 서버는 같은 클라이언트에 유니크 아이디가 현재 사용되는 세션인지 확인 해야만 합니다. 만약 세션이 존재한다면 서버는 단지 같은 세션을 클라이언트에 반환하면 됩니다. 한편으로는 클아이언트에 해당된 세션 아이디가 존재하지 않는다면 서버는 완전히 새로운 세션을 생성합니다.(이것은 서버가 해당 세션아이디를 삭제 했을 경우 발생하는 흔한일이지만 유저는 기존 세션이 새로운 세션이 추가해서 갖게 됩니다)  

The session itself is not complex but its implementation and deployment are, so you cannot use "one way to rule them all".  
세션 자체는 복잡하지 않지만 구현과 배포는 복잡합니다. 그러므로 당신은 "그 모든것에 적용되는 단 한가지 방법을" 사용하면 안됩니다.

## Summary
## 요약

In conclusion, the purpose of sessions and cookies are the same. They are both for overcoming the statelessness of HTTP, but they use different ways. Sessions use cookies to save session ids on the client side, and save all other information on the server side. Cookies save all client information on the client side. You may have noticed that cookies have some security problems. For example, usernames and passwords can potentially be cracked and collected by malicious third party websites.  
결론적으로 세션과 쿠키의 목적은 동일합니다. 그것들은 둘다 HTTP의 상태가 없는것을 극복하기 위한것 이지만 다른 방법으로 사용합니다. 세션은 세션 아이디를 쿠키에 담아 클라이언트 사이드에 저장하고, 나머지 모든 정보들을 서버 사이드에 저장합니다. 쿠키는 모든 정보를 클라이언트 사이드에 저장합니다. 당신은 아마도 쿠키가 약간의 보안 문제가 있음을 알았을 것입니다. 예를 들자면 유저네임과 패스워드를 저장 하는것은 잠재적으로 크래킹 당하거나 악성적인 third-party 웹사이트로부터 수집될수 있습니다. 

Here are two common exploits:  
자주 사용되는 두가지 공격:

1. appA setting an unexpected cookie for appB.
2. XSS attack: appA uses the JavaScript `document.cookie` to access the cookies of appB.

1. appA에서 appB를 위한 예기치 않은 쿠키 세팅.
2. XSS 공격: appA에서 JavaScript의 `document.cookie`를 이용하여 appB의 쿠키에 접근.

After finishing this section, you should know some of the basic concepts of cookies and sessions. You should be able to understand the differences between them so that you won't kill yourself when bugs inevitably emerge. We'll discuss sessions in more detail in the following sections.  
이 섹션이 끝난후 쿠키와 세션의 기본적인 컨셉에 대해 알았을 것입니다. 당신은 쿠키와 세션의 차이를 알아야만 하며 그러지 않을경우 필연적인 버그가 등장해서 당신을 죽도록 고통스럽게 할 것입니다. 우리는 다음장에서 세션에 대해 보다 상세히 다룰것입니다.

## Links

- [Directory](preface.md)
- Previous section: [Data storage and session](06.0.md)
- Next section: [How to use session in Go](06.2.md)
